/* Copyright(C) 2023 Hulevych */

#include <cppast/cpp_function.hpp>
#include <cppast/cpp_function_type.hpp>
#include <cppast/cpp_member_function.hpp>
#include <cppast/detail/assert.hpp>
#include <cppast/libclang_parser.hpp>
#include <cppast/visitor.hpp>

#include <cxxopts.hpp>

#include <filesystem>
#include <fstream>
#include <iostream>
#include <stack>

#include <assert.h>

#include "options.h"
#include "printers.h"

using namespace cppast;
using namespace gunit::tool;

namespace {

void print_error(const std::string& msg) {
  std::cerr << msg << '\n';
}

void print_help(const cxxopts::Options& options) {
  std::cout << options.help({"", "compilation"}) << '\n';
}

}  // namespace

constexpr const auto* GeneratedFileHeader =
    R"(/* This file is auto-generated by gunit tool */)";

struct NamespacesStack final {
  void operator()(std::ostream& os) {
    if (!m_inside) {
      os << "namespace " << GeneratedNamespaceName << " {\n\n";
      m_inside = true;
    }
  }

  void push(std::ostream& os, const std::string& scope) {
    m_namespaces.push(scope);
    assert(!m_inside);
    printNamespace(os, m_namespaces.top(), true);
  }

  void pop(std::ostream& os) {
    if (m_inside) {
      os << "} // namespace " << GeneratedNamespaceName << std::endl;
      m_inside = false;
    }
    printNamespace(os, m_namespaces.top(), false);
    m_namespaces.pop();
  }

  const char* top() const {
    return !m_namespaces.empty() ? m_namespaces.top().c_str() : nullptr;
  }

 private:
  std::stack<std::string> m_namespaces;
  bool m_inside = false;
};

struct CodeGenerator {
  explicit CodeGenerator(std::ostream& out, const cpp_entity_index& idx)
      : m_out(out), m_idx(idx) {}

  void handleAccess(const cpp_entity& e) {
    assert(e.kind() == cpp_entity_kind::access_specifier_t);
  }

  void handleClass(const cpp_class& e, const bool enter) {
    if (e.class_kind() != cpp_class_kind::class_t) {  // TODO: rework
      return;
    }

    if (enter) {
      m_class = std::addressof(e);
    } else {
      m_class = nullptr;
    }
  }

  void handleNamespace(const cpp_entity& e, const bool enter) {
    if (enter) {
      m_namespaces.push(m_out, e.name());
    } else {
      m_namespaces.pop(m_out);
    }
  }

 protected:
  NamespacesStack m_namespaces;
  const cpp_class* m_class = nullptr;  // TODO: stack to support nested classes

  std::ostream& m_out;
  const cpp_entity_index& m_idx;
};

struct HeaderCodeGenerator final : CodeGenerator {
  HeaderCodeGenerator(std::ostream& out, const cpp_entity_index& idx)
      : CodeGenerator(out, idx) {}
  ~HeaderCodeGenerator() = default;

  void handleClass(const cpp_class& e, const bool enter) {
    if (e.class_kind() != cpp_class_kind::class_t) {  // TODO: rework
      return;
    }

    CodeGenerator::handleClass(e, enter);

    if (enter) {
      m_namespaces(m_out);
    }
    printClass(m_out, e, m_namespaces.top(), m_access == "private", enter);
  }

  void handleConstructor(const cpp_constructor& e) {
    if (m_class == nullptr) {
      return;
    }

    assert(m_class->name() == e.name());
    printConstructorDecl(m_out, m_idx, e, false);
  }

  void handleAccess(const cpp_entity& e) {
    if (m_class == nullptr) {
      return;
    }

    assert(e.kind() == cpp_entity_kind::access_specifier_t);
    if (m_access != e.name()) {
      m_access = e.name();
      m_out << e.name() << ":\n";
    }
  }

  void handleFreeFunction(const cpp_function& e) {
    m_namespaces(m_out);

    printFunctionDecl(m_out, m_idx, e, nullptr, true);

    m_out << std::endl;
  }

  void handleMemberFunction(const cpp_member_function& e) {
    if (m_class == nullptr) {
      return;
    }

    m_namespaces(m_out);

    printFunctionDecl(m_out, m_idx, e, nullptr, true);

    m_out << std::endl;
  }

 private:
  std::string m_access;
};

struct SourceCodeGenerator final : CodeGenerator {
  SourceCodeGenerator(std::ostream& out, const cpp_entity_index& idx)
      : CodeGenerator(out, idx) {}
  ~SourceCodeGenerator() = default;

  void handleConstructor(const cpp_constructor& e) {
    if (m_class == nullptr) {
      return;
    }

    assert(m_class->name() == e.name());
    m_namespaces(m_out);

    printConstructorDecl(m_out, m_idx, e, true);
    printBaseClassesConstructors(m_out, m_class->bases(), m_namespaces.top());
    printConstructorBody(m_out, m_idx, e, m_namespaces.top());

    m_out << std::endl;
  }

  void handleFreeFunction(const cpp_function& e) {
    m_namespaces(m_out);

    printFunctionDecl(m_out, m_idx, e, nullptr, false);
    printFunctionBody(m_out, m_idx, e, m_namespaces.top());

    m_out << std::endl;
  }

  void handleMemberFunction(const cpp_member_function& e) {
    if (m_class == nullptr) {
      return;
    }

    m_namespaces(m_out);

    printFunctionDecl(m_out, m_idx, e, m_class->name().c_str(), false);
    printFunctionBody(m_out, m_idx, e);

    m_out << std::endl;
  }
};

template <typename GeneratorType>
void process_file(GeneratorType& generator, const cpp_file& file) {
  visit(file, [&](const cpp_entity& e, visitor_info info) {
    const auto enter = info.event == visitor_info::container_entity_enter;
    switch (e.kind()) {
      case cpp_entity_kind::namespace_t:
        generator.handleNamespace(e, enter);
        break;
      case ::cpp_entity_kind::function_t:
        generator.handleFreeFunction(static_cast<const cpp_function&>(e));
        break;
      case ::cpp_entity_kind::class_t:
        generator.handleClass(static_cast<const cpp_class&>(e), enter);
        break;
      case ::cpp_entity_kind::constructor_t:
        generator.handleConstructor(static_cast<const cpp_constructor&>(e));
        break;
      case ::cpp_entity_kind::access_specifier_t:
        generator.handleAccess(e);
        break;
      case ::cpp_entity_kind::member_function_t:
        generator.handleMemberFunction(
            static_cast<const cpp_member_function&>(e));
        break;
      default:
        break;
    }
  });
}

std::unique_ptr<cpp_file> parse_file(const libclang_compile_config& config,
                                     const diagnostic_logger& logger,
                                     const std::string& filename,
                                     const cpp_entity_index& idx,
                                     bool fatal_error) {
  // the parser is used to parse the entity
  // there can be multiple parser implementations
  libclang_parser parser(type_safe::ref(logger));
  // parse the file
  auto file = parser.parse(idx, filename, config);
  if (fatal_error && parser.error())
    return nullptr;
  return file;
}

void printHeader(const std::string& outputFile,
                 const cppast::cpp_entity_index& idx,
                 const cppast::cpp_file& file) {
  std::ofstream headerStream(outputFile + ".h");
  HeaderCodeGenerator header(headerStream, idx);

  headerStream << GeneratedFileHeader << "\n\n";
  headerStream << "#pragma once\n\n";
  headerStream << "#include <memory>\n\n";
  headerStream << "#include \"" << file.name() << "\"\n\n";

  process_file(header, file);
}

void printSource(const std::string& outputFile,
                 const cppast::cpp_entity_index& idx,
                 const cppast::cpp_file& file) {
  std::ofstream sourceStream(outputFile + ".cpp");
  SourceCodeGenerator source(sourceStream, idx);

  sourceStream << GeneratedFileHeader << "\n\n";
  sourceStream << "#include \"" << outputFile + ".h"
               << "\"\n\n";
  sourceStream << "#include <recorder/actions_observer.h>\n\n";

  process_file(source, file);
}

int main(int argc, char* argv[]) {
  try {
    auto option_list = getOptions();
    option_list.parse_positional("file");

    auto options = option_list.parse(argc, argv);
    if (options.count("help"))
      print_help(option_list);
    else if (options.count("version")) {
      std::cout << "gunit version "
                << "1.0"
                << "\n";
    } else if (!options.count("file") ||
               options["file"].as<std::string>().empty()) {
      print_error("missing file argument");
      return 1;
    } else {
      // the compile config stores compilation flags
      const libclang_compile_config config = buildConfig(options);

      // the logger is used to print diagnostics
      stderr_diagnostic_logger logger;
      if (options.count("verbose"))
        logger.set_verbose(true);

      cpp_entity_index idx;
      auto file = parse_file(config, logger, options["file"].as<std::string>(),
                             idx, options.count("fatal_errors") == 1);
      if (!file)
        return 2;

      const auto outFilePath =
          getOutputFilePathWithoutExtension(file->name(), options);

      printHeader(outFilePath, idx, *file);
      printSource(outFilePath, idx, *file);
    }
  } catch (const std::exception& ex) {
    print_error(std::string("[fatal parsing error] ") + ex.what());
    return 2;
  }
}
