#include "options.h"

#include <cppast/libclang_parser.hpp>
#include <cxxopts.hpp>

#include <filesystem>

#include <assert.h>

using namespace cppast;
using namespace cxxopts;

namespace cider {
namespace tool {

Options getOptions() {
  Options option_list("cider", "cider generates recording wrappers.\n");
  // clang-format off
    option_list.add_options()
        ("h,help", "display this help and exit")
        ("version", "display version information and exit")
        ("lua", "generate producers for recorder and lua")
        ("swig", "generate only swig wrapper with given module name", value<std::string>())
        ("v,verbose", "be verbose when parsing")
        ("fatal_errors", "abort program when a parser error occurs, instead of doing error correction")
        ("file", "the file that is being parsed (last positional argument)",
         value<std::string>())
        ("files", "the files that are being parsed(paths separated by ; or :)",
             value<std::string>())
        ("out_dir", "the directory which is used for output files generation",
         value<std::string>()->default_value("."))
        ("namespace", "the namespace which is used for output entities generation",
         value<std::string>()->default_value("cider3"))
        ("integration_file", "the file that contains standart headers",
         value<std::string>());

        option_list.add_options("compilation")
        ("database_dir", "set the directory where a 'compile_commands.json' file is located containing build information",
            value<std::string>())
        ("database_file", "set the file name whose configuration will be used regardless of the current file name",
            value<std::string>())
        ("std", "set the C++ standard (c++98, c++03, c++11, c++14, c++1z (experimental), c++17, c++2a, c++20)",
         value<std::string>()->default_value(to_string(cpp_standard::cpp_latest)))
        ("I,include_directory", "add directory to include search path",
         value<std::vector<std::string>>())
        ("D,macro_definition", "define a macro on the command line",
         value<std::vector<std::string>>())
        ("U,macro_undefinition", "undefine a macro on the command line",
         value<std::vector<std::string>>())
        ("f,feature", "enable a custom feature (-fXX flag)",
         value<std::vector<std::string>>())
        ("gnu_extensions", "enable GNU extensions (equivalent to -std=gnu++XX)")
        ("msvc_extensions", "enable MSVC extensions (equivalent to -fms-extensions)")
        ("msvc_compatibility", "enable MSVC compatibility (equivalent to -fms-compatibility)")
        ("fast_preprocessing", "enable fast preprocessing, be careful, this breaks if you e.g. redefine macros in the same file!")
        ("remove_comments_in_macro", "whether or not comments generated by macro are kept, enable if you run into errors");
  // clang-format on
  return option_list;
}

cppast::libclang_compile_config buildConfig(const ParseResult& options,
                                            const std::string path) {
  // the compile config stores compilation flags
  libclang_compile_config config;
  if (options.count("database_dir")) {
    libclang_compilation_database database(
        options["database_dir"].as<std::string>());

    auto config_ = find_config_for(database, path);
    assert(config_.has_value());
    config = config_.value();
  }

  if (options.count("verbose"))
    config.write_preprocessed(true);

  if (options.count("fast_preprocessing"))
    config.fast_preprocessing(true);

  if (options.count("remove_comments_in_macro"))
    config.remove_comments_in_macro(true);

  if (options.count("include_directory"))
    for (auto& include :
         options["include_directory"].as<std::vector<std::string>>())
      config.add_include_dir(include);
  if (options.count("macro_definition"))
    for (auto& macro :
         options["macro_definition"].as<std::vector<std::string>>()) {
      auto equal = macro.find('=');
      auto name = macro.substr(0, equal);
      if (equal == std::string::npos)
        config.define_macro(std::move(name), "");
      else {
        auto def = macro.substr(equal + 1u);
        config.define_macro(std::move(name), std::move(def));
      }
    }
  if (options.count("macro_undefinition"))
    for (auto& name :
         options["macro_undefinition"].as<std::vector<std::string>>())
      config.undefine_macro(name);
  if (options.count("feature"))
    for (auto& name : options["feature"].as<std::vector<std::string>>())
      config.enable_feature(name);

  // the compile_flags are generic flags
  compile_flags flags;
  if (options.count("gnu_extensions"))
    flags |= compile_flag::gnu_extensions;
  if (options.count("msvc_extensions"))
    flags |= compile_flag::ms_extensions;
  if (options.count("msvc_compatibility"))
    flags |= compile_flag::ms_compatibility;

  if (options["std"].as<std::string>() == "c++98")
    config.set_flags(cpp_standard::cpp_98, flags);
  else if (options["std"].as<std::string>() == "c++03")
    config.set_flags(cpp_standard::cpp_03, flags);
  else if (options["std"].as<std::string>() == "c++11")
    config.set_flags(cpp_standard::cpp_11, flags);
  else if (options["std"].as<std::string>() == "c++14")
    config.set_flags(cpp_standard::cpp_14, flags);
  else if (options["std"].as<std::string>() == "c++1z")
    config.set_flags(cpp_standard::cpp_1z, flags);
  else if (options["std"].as<std::string>() == "c++17")
    config.set_flags(cpp_standard::cpp_17, flags);
  else if (options["std"].as<std::string>() == "c++2a")
    config.set_flags(cpp_standard::cpp_2a, flags);
  else if (options["std"].as<std::string>() == "c++20")
    config.set_flags(cpp_standard::cpp_20, flags);
  else if (options["std"].as<std::string>() == "c++2b")
    config.set_flags(cpp_standard::cpp_2b, flags);
  else {
    throw std::logic_error{"Invalid value for --std command-line argument."};
  }

  return config;
}

std::string getOutputFilePathWithoutExtension(const std::string& inputFilePath,
                                              const std::string& outDir) {
  std::filesystem::path outFilePath;
  const auto fileName = std::filesystem::path(inputFilePath).stem();
  const std::filesystem::path outDirPath = outDir;
  if (std::filesystem::is_directory(outDirPath)) {
    outFilePath = outDirPath / fileName;
  }
  return outFilePath.string();
}

std::string getOutputFilePath(const cxxopts::ParseResult& options) {
  const auto outDir =
      std::filesystem::path(options["out_dir"].as<std::string>());
  std::filesystem::create_directories(outDir);
  return outDir.string();
}

}  // namespace tool
}  // namespace cider
